#!/usr/bin/env python3
import asyncio
import json
import time

import rclpy
from rclpy.node import Node
from std_msgs.msg import Bool, UInt8
from stack_msgs.msg import StackCommand
import websockets


HELP = """
websocket_teleop_bridge: WebSocket teleop + mode control

  全局行驶状态 (/drive_cmd):
    x -> ESTOP (drive_cmd = 2) 再按 t 可退出 ESTOP，恢复 RUN + 手动 teleop
    f -> TASK DONE (/task_done True)
    t -> TOGGLE 自动循迹 / 手动 teleop (通过 /teleop_active)
         teleop_active = True  -> 手动 teleop (通过 /stack_cmd/teleop 控制)
         teleop_active = False -> 自动循迹 (跟随 /stack_cmd/traj)

  Teleop 速度 (pre_speed_kmh)：
    0 ->  0 km/h
    4 ->  4 km/h
    8 ->  8 km/h
    1 -> -4 km/h (后退)

  Teleop 方向 (angle_deg)：
    a -> -10 deg (小左)
    d -> +10 deg (小右)
    q -> -20 deg (大左)
    e -> +20 deg (大右)
    c ->  0 deg  (直行)

  作业位 (仅影响 teleop 的 StackCommand)：
    j -> TOGGLE dump
    k -> TOGGLE pick
    l -> TOGGLE unload
    h -> TOGGLE pick_action

"""

DEBOUNCE_SEC = 0.15


class WebSocketTeleopBridge(Node):
    def __init__(self):
        super().__init__('websocket_teleop_bridge')

        # 发布者
        self.pub_drive_cmd = self.create_publisher(UInt8, '/drive_cmd', 1)
        self.pub_task_done = self.create_publisher(Bool, '/task_done', 1)
        self.pub_teleop_act = self.create_publisher(Bool, '/teleop_active', 1)
        self.pub_teleop_cmd = self.create_publisher(
            StackCommand, '/stack_cmd/teleop', 1
        )

        # 内部状态
        # 0=PAUSE(不用),1=RUN,2=ESTOP；默认 RUN
        self.drive_state = 1
        # True=手动 teleop, False=自动循迹；默认手动
        self.teleop_active = True

        self.pre_speed_kmh = 0.0
        self.angle_deg = 0.0
        self.pick = False
        self.unload = False
        self.dump = False
        self.pick_action = False

        self.last_ts = {}

        self.get_logger().info(HELP)

        # 初始广播一次
        self.publish_drive_cmd()
        self.publish_teleop_active()
        self.publish_teleop_cmd()

    # --- 工具：去抖 ---
    def debounce(self, key: str) -> bool:
        now = time.time()
        last = self.last_ts.get(key, 0.0)
        if (now - last) < DEBOUNCE_SEC:
            return False
        self.last_ts[key] = now
        return True

    # --- 发布函数 ---
    def publish_drive_cmd(self):
        msg = UInt8()
        msg.data = int(self.drive_state)
        self.pub_drive_cmd.publish(msg)
        self.get_logger().info(f"/drive_cmd -> {self.drive_state}")

    def publish_task_done(self):
        msg = Bool()
        msg.data = True
        self.pub_task_done.publish(msg)
        self.get_logger().info("TASK DONE sent")

    def publish_teleop_active(self):
        msg = Bool()
        msg.data = bool(self.teleop_active)
        self.pub_teleop_act.publish(msg)
        self.get_logger().info(
            f"/teleop_active -> {self.teleop_active} "
            "(True=手动 teleop, False=自动循迹)"
        )

    def publish_teleop_cmd(self):
        msg = StackCommand()
        msg.pre_speed_kmh = float(self.pre_speed_kmh)
        msg.angle_deg = float(self.angle_deg)
        msg.dist_to_target_m = 0.0
        msg.pick = bool(self.pick)
        msg.unload = bool(self.unload)
        msg.dump = bool(self.dump)
        msg.pick_action = bool(self.pick_action)
        msg.valid = True
        self.pub_teleop_cmd.publish(msg)
        self.get_logger().info(
            "TELEOP CMD: "
            f"speed={self.pre_speed_kmh} km/h, angle={self.angle_deg} deg, "
            f"pick={self.pick}, unload={self.unload}, "
            f"dump={self.dump}, pick_action={self.pick_action}"
        )

    # --- 按键语义（与 TeleopKey 一致，只是输入来自 WebSocket） ---
    def handle_key(self, c: str):
        if not c:
            return
        c = c.lower()

        # -------- ESTOP --------
        if c == 'x':
            if not self.debounce(c):
                return
            self.drive_state = 2  # ESTOP
            self.publish_drive_cmd()
            return

        # -------- 任务点完成 --------
        if c == 'f':
            if not self.debounce(c):
                return
            self.publish_task_done()
            return

        # -------- 模式切换 (t) --------
        if c == 't':
            if not self.debounce(c):
                return
            if self.drive_state == 2:
                # 从 ESTOP 恢复：设 RUN + 手动 teleop
                self.drive_state = 1
                self.publish_drive_cmd()
                self.teleop_active = True
                self.publish_teleop_active()
            else:
                # 在 RUN 状态下，在手动/自动之间切换
                self.teleop_active = not self.teleop_active
                self.publish_teleop_active()
            return

        # -------- Teleop 速度 --------
        if c in ('0', '1', '4', '8'):
            if not self.debounce(c):
                return
            if c == '0':
                self.pre_speed_kmh = 0.0
            elif c == '4':
                self.pre_speed_kmh = 4.0
            elif c == '8':
                self.pre_speed_kmh = 8.0
            elif c == '1':
                self.pre_speed_kmh = -4.0  # 后退
            self.publish_teleop_cmd()
            return

        # -------- Teleop 方向 --------
        if c in ('a', 'd', 'q', 'e', 'c'):
            if not self.debounce(c):
                return
            if c == 'a':
                self.angle_deg = -10.0
            elif c == 'd':
                self.angle_deg = 10.0
            elif c == 'q':
                self.angle_deg = -20.0
            elif c == 'e':
                self.angle_deg = 20.0
            elif c == 'c':
                self.angle_deg = 0.0
            self.publish_teleop_cmd()
            return

        # -------- 作业位 --------
        if c in ('j', 'k', 'l', 'h'):
            if not self.debounce(c):
                return
            if c == 'j':
                self.dump = not self.dump
            elif c == 'k':
                self.pick = not self.pick
            elif c == 'l':
                self.unload = not self.unload
            elif c == 'h':
                self.pick_action = not self.pick_action
            self.publish_teleop_cmd()
            return

        self.get_logger().warn(f"Unknown key: {c}")

    # --- WebSocket 处理 ---
    async def handle_client(self, websocket, path):
        client_addr = websocket.remote_address
        self.get_logger().info(f"Client connected from {client_addr}")
        try:
            async for message in websocket:
                try:
                    data = json.loads(message)
                except json.JSONDecodeError:
                    self.get_logger().error("Received invalid JSON")
                    continue

                # 推荐：使用 {"key": "..."}，直接复用键盘 teleop 逻辑
                if 'key' in data:
                    key = str(data['key'])[:1]  # 只取第一个字符
                    self.handle_key(key)
                    continue

                # 可选扩展：额外的显式指令
                msg_type = data.get('type')

                if msg_type == 'task_done':
                    # {"type": "task_done"}
                    if self.debounce('task_done'):
                        self.publish_task_done()
                    continue

                if msg_type == 'drive':
                    # {"type": "drive", "state": 1}  # 0/1/2
                    state = data.get('state')
                    if state in (0, 1, 2):
                        self.drive_state = int(state)
                        self.publish_drive_cmd()
                    else:
                        self.get_logger().warn(f"Invalid drive state: {state}")
                    continue

                if msg_type == 'active':
                    # {"type": "teleop_active", "value": true}
                    val = data.get('value')
                    if isinstance(val, bool):
                        if self.drive_state == 2 and val:
                            self.drive_state = 1
                            self.publish_drive_cmd()
                            self.teleop_active = True
                            self.publish_teleop_active()
                        else:
                            self.teleop_active = val
                            self.publish_teleop_active()
                    else:
                        self.get_logger().warn(f"Invalid teleop_active value: {val}")
                    continue

                if msg_type == 'cmd':
                    # {"type": "teleop_cmd", "pre_speed_kmh": 4, "angle_deg": 10, ...}
                    updated = False
                    if "pre_speed_kmh" in data:
                        self.pre_speed_kmh = float(data["pre_speed_kmh"])
                        updated = True
                    if "angle_deg" in data:
                        self.angle_deg = float(data["angle_deg"])
                        updated = True
                    if "pick" in data:
                        self.pick = bool(data["pick"])
                        updated = True
                    if "unload" in data:
                        self.unload = bool(data["unload"])
                        updated = True
                    if "dump" in data:
                        self.dump = bool(data["dump"])
                        updated = True
                    if "pick_action" in data:
                        self.pick_action = bool(data["pick_action"])
                        updated = True

                    if updated:
                        self.publish_teleop_cmd()
                    else:
                        self.get_logger().warn(f"No recognized fields in teleop_cmd: {data}")
                    continue

                self.get_logger().warn(f"Unknown message: {data}")

        except websockets.exceptions.ConnectionClosed:
            self.get_logger().info(f"Client {client_addr} disconnected")
        except Exception as e:
            self.get_logger().error(f"Unexpected error: {e}")

    async def start_server(self):
        server = await websockets.serve(
            self.handle_client,
            "0.0.0.0",
            9010,
            ping_interval=20,
            ping_timeout=10,
        )
        self.get_logger().info("WebSocket teleop bridge listening on ws://0.0.0.0:9010")
        await server.wait_closed()


def main(args=None):
    rclpy.init(args=args)
    node = WebSocketTeleopBridge()

    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(node.start_server())
    except KeyboardInterrupt:
        node.get_logger().info("Shutting down WebSocket teleop bridge...")
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
